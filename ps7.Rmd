---
title: "ps7"
author: "Hannah Olson-Williams"
date: "12/5/2021"
output: word_document
---

### QUESTION 2 PART A 

Intrinsic rate of natural increase for the russian female population of 2000 

Is nma the same as B/N?! 
nma = rate of bearing female children between ages a and a+5 
B/N = female births / female population 

preston p114: NRR = 1/l0 * sum(nFx*nLx)
where nFx = nBx/nWx 
```{r}
setwd("H:/soci756")
d= read.csv("ps7.csv")
d = d[is.na(d$age) == FALSE,] #remove na row 

#remove commas and reformat nlx values 
d$nLx = as.numeric(gsub(",","",d$nLx))

#calculate the nMa values: rate of bearing female children between ages a and a+5
d$nma = d$B/ d$N
d$lm = d$nma* d$nLa

#subset data for maternal ages only 
dmat = d[d$age >10 & d$age <=45,]
r0 = log(sum(dmat$nLa*dmat$nma, na.rm = TRUE))/27 

NRR = sum(dmat$nLa*dmat$nma, na.rm = TRUE)


for (a in 15:45) {
yrn = function(rn){
  exp(-rn*(a+2.5))*d$nLa[d$age == a]*d$nma[d$age == a]
}}

r1 = r0 + ((yrn(r0)-1)/27)
r2 = r1 + ((yrn(r1)-1)/27)
r3 = r2 + ((yrn(r2)-1)/27)
r4 = r3 + ((yrn(r3)-1)/27)
r5 = r4 + ((yrn(r4)-1)/27)
```
The NRR of the population is `r NRR`. 
After three iterations, we obtain `r r3` for the intrinsic growth rate of Russia in 2000. 


### QUESTION 2 PART B
The "real" mean length of generation in the Russian population of 2000:

NRR = e^(r*t) -> ln(NRR) = r*t -> t = ln(NRR)/ r 
```{r}
t = log(NRR) / r3 

t
```
The number of years required for the population to grow (at the intrinsic growth rate) by the factor equal to the 2000 next reproduction rate is `r t`. 

### QUESTION 2 PART C
Intrinsic age distribution of the Russian female population in 2000 
```{r}
d$bdenom = exp(-r3*(d$age+2.5))*(d$nLa/100000)
b = 1/sum(d$bdenom)


d$cstable = b*d$bdenom 
d$cactual = d$N / sum(d$N)

#print entire dataframe 
d
```

### QUESTION 2 PART D 
```{r}
library(ggplot2)

#make a new dataset to play nicely with ggplot 
dplot = data.frame(age = rep(d$age, 2), c = c(d$cstable, d$cactual), group = c(rep("Intrinsic", 21), rep("Actual", 21)))

ggplot(dplot) + geom_point(aes(x = age, y = c, shape = group, color = group), size = 3) +
  xlab("Age a") + 
  ylab("5Ca") +
  ggtitle("Actual versus Intrinsic Age Distributions")+
  theme_bw() +
  theme(legend.title = element_blank())

```
The difference between the age distribution in Russia in 2000 and the age distribution of the stable equivalent population is that the stable equivalent population grows until expected age of death at around age 80. On the other hand, the actual age distribution in Russia steadily declines after age 50 as as age increases. The actual age distribution follows a less strict pattern and seemingly includes greater variation in birth and death rates.  
Given that the intrinsic growth rate r3 that I calculated in part a has approximately 20 times greater magnitude than CRNI = -0.006, it makes sense that the actual and intrinsic age distributions are substantially different. Additionally, as stated on Preston page 148, populations in Europe and North America are expected to have large discrepancies between the intrinsic growth rate and the CRNI since large changes in fertility and mortality rates have "destabilized" these populations over time.    

### QUESTION 2 PART E 
Intrinsic death rate 
```{r}
idr = b-r3
idr
```
The intrinsic death rate is `r idr`. 





### QUESTION 3 

a) Simulate a population with only two birth cohorts of 10,000 people each 

```{r}

#this simulates a lifetable style cohort with nlx at each age as the cohort ages 
c1 = data.frame(age = d$age, nlx = round(d$nLx*10000/492543, 0)) #this is the russian birth cohort from problem 2 
c2 = data.frame(age = d$age, nlx = round(d$nLx*10000/492543*runif(1, 0.9, 1.01), 0)) #this is the russian birth cohort from problem 2 with slightly randomized nlx values 
c2$nlx[1] = 10000

#this simulates an individual level cohort with each id representing an unique member of the population 
p1 = data.frame(id = 1:10000)
p2 = data.frame(id = 1:10000)

```

b) Assign frailty values that are normally distributed 
I tried to use a gamma distribution to avoid negative frailty values. 
```{r}

#for (i in 1:nrow(c1)) {
  #c1$frailty[i] = rnorm(1,2, sd = 1)
  #c2$frailty[i] = rnorm(1,2, sd = 1)
  #c1$frailty[i] = rgamma(1,2)
  #c2$frailty[i] = rgamma(1,2)
#}


for (i in 1:nrow(p1)) {
  #p1$frailty[i] = rnorm(1,2, sd = 1)
  #p2$frailty[i] = rnorm(1,2, sd = 1)
  p1$frailty[i] = rgamma(1,2)
  p2$frailty[i] = rgamma(1,2)
}


p1 = p1[order(p1$frailty),]
p2 = p2[order(p2$frailty),]

#for (i in 2:nrow(c1)) {
#  c1$nlx[i] = c1$nlx[i-1] * c1$frailty[i-1]
#  c2$nlx[i] = c2$nlx[i-1] * c2$frailty[i-1]
#}

```

c) Generate a mortality function that ignores mortality before age 35 and assumes gompertz mortality after age 35. 
Set mortality in cohort2 to be 30% higher than mortality in cohort1 

Gompertz: u(age) = alpha * e^(Beta)*age 

```{r}
alpha = 0.002 #these values were selected from Alexander's plot 
Beta = 0.05 

#not needed for now 
#mort = function(age) {
#  if(age<35) {
#  print(alpha)
#  }else if(age>=35) {
#  print(alpha*exp(Beta*age))  
#  }
#}

#death rates are 1.3 times greater in cohort 2 than in cohort 1 
c1$mort = as.numeric(ifelse(c1$age>=35, alpha*exp(Beta*c1$age), "")) #this is function mu(x) from alexander 
c2$mort = as.numeric(c1$mort)*1.3

c1$alive[1:7] = 10000
c2$alive[1:7] = 10000
for (i in 8:length(c1$age)){
  c1$alive[i] = c1$alive[i-1] - (c1$alive[i-1]*c1$mort[i])
  c2$alive[i] = c2$alive[i-1] - (c1$alive[i-1]*c1$mort[i])
}

#calculate frailty for each age group 
for (i in 8:length(c1$age)){
  c1$frail[i] = 
}


c1$survive = exp((alpha/Beta) * (exp(Beta*c1$age)-1)) #this is function l(x) from alexander
c2$survive = exp((alpha*1.3/Beta) * (exp(Beta*c2$age)-1))
c1$deathdensity = alpha*exp(Beta*c1$age)*exp((-alpha/Beta)*exp(Beta*c1$age)-1)
c2$deathdensity = alpha*exp(Beta*c2$age)*exp((-alpha/Beta)*exp(Beta*c2$age)-1)

#this is from alexander's page... an attempt to interpret her parameter D 
#Dc1 = sum(c1$frailty) 
#Dc2 = sum(c2$frailty) #i'm unsure if this is the correct interpretation/use of frailty, but it seems to make some amount of sense....
#c1$ndeath = Dc1*c1$deathdensity

pi0 = 0.95
c1$pi = (pi0*c1$survive)/ (pi0*c1$survive + (1-pi0)*c2$survive) #this is eq2 from 
c1$meanmort = c1$pi*c1$mort + (1-c1$pi)*c2$mort

```

pi(x) = proportion of surviving cohort at age x 
u1(x) = hazard rate for c1 
u2(x) = hazard rate for c2 

pi(x) = pi(0)*p1 / ( pi(0)*p1 + (1 - pi(0))*p2 ) 


follow vaupel and yashin paper 
alpha and beta: get from monica paper/website referenced by jenna on canvas note 
shouldn't be too sensitive to alpha and beta choices 
use pi from vaupel and yashin to average cohorts to plot final dist (? i think that's what becca's q meant) 


how to use frailty? 
include frailty as part of mortality function (hazard) 
because we've been working in discrete time, another way to do this is to sort 
treat frailty as individual probability (proclivity) of death
keep an indicator var at each age to flag who is alive at each age 
sort survivors on frailty 
once we have deaths for cohort, we can change the flag for people who are most frail 

CHECK maybe should gamma distribute frailty so there's no negative vals; or use normal dist with mean=2 and sd =1 

multiply one cohort by 1.3 when using the downloaded mort rates (? not totally sure what this means?) 


### PLOTS OF MORTALITY RATES AND FRAILTY BY AGE FOR EACH COHORT AND AS A WHOLE 
```{r}
ggplot(c1) + geom_point(aes(x=age, y=log(mort))) +
  geom_point(aes(x=age, y=log(meanmort)))
```

leslie matrix as a markov process 
if nrr implied by relationship between fertility and mortality then pop explodes 
eigenvector will tell us whether relationship goes to infinity or zero 
renewal matrix versus markov : renewal matrix uses counts rather than probability dist -> can leslie and pop vector be rewritten such that pop vector is a proportion instead of pop vector 



